<title>UOttawa Course Schedule</title>
<body>
	<textarea id="i"></textarea>
	<button id="go">go (then, enter to return)</button>
	<table id="table"></table>
</body>

<style>
table, th, td { border: 1px solid; border-collapse: collapse; padding: 10px; text-align: center; margin: 30px; }
</style>

<script>
const timeToMilitary = s => {
	const [h, m] = s.split(":"), hour = +h, min = (+m[0] >> 1) / 2, ampm = m.match(/PM/) && hour !== 12 ? 12 : 0
	return hour + min + ampm }

const militaryToTime = t => {
	const hour = ~~(t < 13 ? t : t-12), min = (t%1 * 60 + "").padStart(2, "0"); return `${hour}:${min}` }

const parse = s => { s = s.split("\n").filter(l => l.trim())
	let colours = ["LightSkyBlue", "Tomato", "Wheat", "Gold", "LightGreen", "Thistle", "AliceBlue", "Orange"]
	const useColour = _ => colours.splice(~~(Math.random() * colours.length), 1)[0]
	const parseWhile = (cond, parse, after = _ => {}) => { const a = []; while (cond()) a.push(parse()), after(); return a }

	const parseDay      = date => ["Mo", "Tu", "We", "Th", "Fr"].indexOf(date.slice(0, 2))
	,     parseTime     = date => date.slice(2).split(" - ").map(timeToMilitary)
	,     parseLocation = _ => s.shift().split("(")[1].replace(")", "")
	,     parseEvent    = _ => ({ day: parseDay(s[0]), time: parseTime(s.shift()), location: parseLocation() })
	,     parseSection  = _ => (s.splice(0, 3), parseWhile(_ => s[0]?.match(/^(Mo|Tu|We|Th|Fr)/), parseEvent, _ => s.splice(0, 2)))
	,     skipHeader    = _ => { while (!s.shift().match(/^Class Nbr/)); }
	,     parseBody     = _ => (skipHeader(), parseWhile(_ => !isNaN(s[0]), parseSection).flat())
	,     parseName     = _ => s.shift().split(" - ")[1]
	,     parseClass    = _ => ({ name: parseName(), events: parseBody(), colour: useColour() })

	const parsed = parseWhile(_ => s.length, parseClass)
	,     events = parsed.map(({ name, events, colour }) => events.map(e => ({ ...e, name, colour }))).flat()
	return Object.values(Object.groupBy(events, e => e.day)).map(day => day.toSorted((d1, d2) => d1.time[0] - d2.time[0])) }

const C = (elt, par, cb = _ => {}) => cb(par.appendChild(document.createElement(elt)))

const makeHeader = h => { h.insertRow();
	["Time", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"].map(t => C("th", h.rows[0], elt => elt.textContent = t)) }

const makeBody = days => b => {
	const times = days.flat().map(m => m.time).flat(), start = Math.min(...times), end = Math.max(...times)
	const addChunk = (s, e, cb) => s < e && C("td", b.rows[(s-start)*2], c => (c.rowSpan = (e-s)*2, cb(c)))
	,     addSpare = (s, e)     => addChunk(s, e, c => c.style.border = "0px")
	const styleEvent  = e => c => (c.innerHTML = `${e.name}<br>${e.location}`, c.style.backgroundColor = e.colour)
	,     addEvent    = e => addChunk(...e.time, styleEvent(e))
	,     handleEvent = (t, e) => e.time[0] < t ? t : (addSpare(t, e.time[0]), addEvent(e), e.time[1])

	for (let t = start; t < end; t += 1/2) b.insertRow().insertCell().textContent = militaryToTime(t)
	days.forEach(d => { const finalClassEnd = d.reduce(handleEvent, start); addSpare(finalClassEnd, end) }) }

const makeTable = days => (C("thead", table, makeHeader), C("tbody", table, makeBody(days)))

go.onclick       = _ => { i.hidden = go.hidden = true; makeTable(parse(i.value)) }
window.onkeydown = e => { if (e.key !== "Enter") return; i.hidden = go.hidden = false; i.value = table.innerHTML = "" }
</script>
